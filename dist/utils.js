// Generated by CoffeeScript 1.10.0
(function() {
  var colors, flatten, getAt, getFirstKey, keys, log, resultsLogger, rtrim, stateOf,
    slice = [].slice;

  colors = {
    reset: "\x1b[0m",
    black: "\x1b[30m",
    red: "\x1b[31m",
    green: "\x1b[32m",
    yellow: "\x1b[33m",
    blue: "\x1b[34m",
    magenta: "\x1b[35m",
    cyan: "\x1b[36m"
  };

  log = function() {
    var c, color, i, rest;
    rest = 2 <= arguments.length ? slice.call(arguments, 0, i = arguments.length - 1) : (i = 0, []), color = arguments[i++];
    if (arguments.length <= 1) {
      return console.log(arguments[0]);
    }
    if (typeof window !== "undefined" && window !== null) {
      rest[0] = "%c" + rest[0];
      return console.log.apply(console, slice.call(rest).concat(["color: " + color]));
    } else {
      if (c = colors[color]) {
        rest[0] = "" + c + rest[0];
        rest.push(colors.reset);
      }
      return console.log.apply(console, rest);
    }
  };

  keys = function(o) {
    if (typeof o === 'object') {
      return Object.keys(o);
    }
  };

  rtrim = function(s, c) {
    if (!(s || c)) {
      return '';
    }
    if (s.slice(-c.length) === c) {
      return s.slice(0, -c.length);
    } else {
      return s;
    }
  };

  stateOf = function(state) {
    if (state) {
      return 'is';
    } else {
      return 'is not';
    }
  };

  flatten = function(arr) {
    return arr.reduce((function(a, b) {
      return a.concat(b);
    }), []);
  };

  getFirstKey = function(obj) {
    var ref1;
    return (ref1 = keys(obj)) != null ? ref1[0] : void 0;
  };

  getAt = function(ref, path) {
    var key, prop;
    path = typeof path.split === "function" ? path.split('.' || path.slice()) : void 0;
    while ((ref != null) && (prop = path.shift())) {
      if (prop === '*') {
        for (key in ref) {
          ref = ref[key];
        }
      } else {
        ref = ref[prop];
      }
    }
    return ref;
  };

  resultsLogger = function(arg, options) {
    var data, i, len, message, passed, ref1, res, result, results, rule;
    passed = arg.passed, results = arg.results;
    if (options == null) {
      options = {};
    }
    log('');
    for (i = 0, len = results.length; i < len; i++) {
      result = results[i];
      res = result[0], message = result[1], (ref1 = result[2], rule = ref1.rule, data = ref1.data);
      if (res) {
        log("    ✓ " + message, 'green');
      } else {
        log("    ✗ " + message, 'red');
        if (options.logDefaults) {
          log("    ℹ value can be '" + rule.val + "' got '" + data + "' instead", 'blue');
        }
      }
    }
    log('');
    if (passed) {
      log("    ✓ ALL PASSED!", 'cyan');
    } else {
      log("    ✗ SOME FAILED!", 'red');
    }
    return log('');
  };

  module.exports = {
    rtrim: rtrim,
    stateOf: stateOf,
    flatten: flatten,
    getFirstKey: getFirstKey,
    keys: keys,
    getAt: getAt,
    log: log,
    resultsLogger: resultsLogger
  };

}).call(this);
